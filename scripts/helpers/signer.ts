// import { BCS, getSuiMoveConfig } from "@mysten/bcs";
// import { BigNumberable, hexStrToUint8 } from "./utils";
// import { sha256 } from "@noble/hashes/sha256";
// import { Keypair, SignatureScheme } from "@mysten/sui.js/cryptography";
// import { ed25519 } from "@noble/curves/ed25519";
// import { secp256k1 } from "@noble/curves/secp256k1";
// import { bytesToHex } from "@noble/hashes/utils";
// import { Ed25519PublicKey } from "@mysten/sui.js/keypairs/ed25519";
// import { Secp256k1PublicKey } from "@mysten/sui.js/keypairs/secp256k1";
//
// export const bcs = new BCS(getSuiMoveConfig());
//
// export interface RewardsPayload {
//   pool: string;
//   receiver: string;
//   amount: BigNumberable; // Must be in 1e9 format
//   nonce: number;
// }
//
// /// Signature payload that is to be signed
// bcs.registerStructType("RewardSignaturePayload", {
//   pool: BCS.ADDRESS, // ID or the address of rewards pool
//   receiver: BCS.ADDRESS, // the address of reward's receiver
//   amount: BCS.U64, // quantity/amount of rewards - MUST be in 9 DECIMAL PLACES
//   nonce: BCS.U128, // a random number
// });
//
// /// The signature data that is to be send on-chain
// bcs.registerStructType("Signature", {
//   sig: "vector<u8>", // the signature generated by the signer using `RewardSignaturePayload`
//   pk: "vector<u8>", // public key of the signer
//   scheme: BCS.U8, // 0 if the wallet type is Secp 1 otherwise (ED25519)
// });
//
// export class Signer {
//   /**
//    * Provided a payload for generating reward signature, serializes it and returns its sha 256 hash to be signed
//    * @param data rewards payload to be signed
//    * @returns sha256 hash of serialized data payload provided as input
//    */
//   static getPayloadHash(data: RewardsPayload): Uint8Array {
//     // take sha256 hash of the serialized data
//     return sha256(bcs.ser("RewardSignaturePayload", data).toBytes());
//   }
//
//   /**
//    * Uses the provided signer key pair to generate signature for the users to use and claim rewards
//    * @param signer KeyPair of the signer. The signer must be the operator/controller of the rewards pool
//    * @param payload The rewards payload to be signed
//    * @returns serialized signature that can be provided to user to perform on-chain `claim_rewards` call.
//    */
//   static sign(signer: Keypair, payload: RewardsPayload): string {
//     // compute hash of the payload
//     const hash = Signer.getPayloadHash(payload);
//
//     // create signature
//     const sig = signer.signData(hash);
//
//     // create signature payload
//     const signature = {
//       sig,
//       pk: signer.getPublicKey().toRawBytes(),
//       scheme: signer.getKeyScheme() == "Secp256k1" ? 0 : 1,
//     };
//
//     // serialize and return the hex of the signature
//     return bcs.ser("Signature", signature).toString("hex");
//   }
//
//   /**
//    * Given an array of data bytes and serialized signature returns true if the signature is valid
//    * @param signature bcs serialized signature (returned by `Signer.sign` method)
//    * @param data data bytes array
//    * @returns True if signature is valid
//    */
//   static verify(signature: string, payload: RewardsPayload): boolean {
//     // de-serialize the signature content
//     const deSig = bcs.de("Signature", signature, "hex");
//     // get hex of the signature
//     const hexSig = Buffer.from(deSig.sig).toString("hex");
//     // extract signer's public key
//     const pk = Uint8Array.from(deSig.pk);
//
//     // get the payload hash that was signed
//     const data = Signer.getPayloadHash(payload);
//
//     // todo add more types!
//     switch (deSig.scheme) {
//       case 0: // Secp256K1
//         return this.verifySECP(hexSig, sha256(data), pk);
//       case 1: // ED25519
//         return ed25519.verify(hexSig, data, pk);
//       default:
//         throw "Signature is created using invalid signer type";
//     }
//   }
//
//   /**
//    * Validates if the provided signature is created using the data and public key provided
//    * @param signature hex encoded signature
//    * @param data data bytes
//    * @param publicKey public key bytes
//    * @returns True if signature is valid
//    */
//   public static verifySECP(
//     signature: string,
//     data: Uint8Array,
//     publicKey: Uint8Array,
//   ): boolean {
//     const sig_r_s = secp256k1.Signature.fromCompact(signature);
//     const sig_r_s_b1 = sig_r_s.addRecoveryBit(0x1);
//     const recovered_pk_1 = sig_r_s_b1
//       .recoverPublicKey(data)
//       .toRawBytes(true)
//       .toString();
//
//     const sig_r_s_b0 = sig_r_s.addRecoveryBit(0x0);
//     const recovered_pk_0 = sig_r_s_b0
//       .recoverPublicKey(data)
//       .toRawBytes(true)
//       .toString();
//
//     return (
//       publicKey.toString() === recovered_pk_1 ||
//       publicKey.toString() === recovered_pk_0
//     );
//   }
//
//   public static getSuiAddressFromPublicKey(
//     publicKey: string | Uint8Array,
//     scheme: SignatureScheme,
//   ) {
//     switch (scheme) {
//       case "ED25519":
//         return new Ed25519PublicKey(publicKey).toSuiAddress();
//       case "Secp256k1":
//         return new Secp256k1PublicKey(publicKey).toSuiAddress();
//       default:
//         throw new Error("Provided scheme is invalid");
//     }
//   }
// }
